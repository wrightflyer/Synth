#include <Arduino.h>
#include <Audio.h>
#include <Wire.h>
#include <SPI.h>
#include <SD.h>
#include <SerialFlash.h>

// TeensyAudioDesign: begin automatically generated code
// the following JSON string contains the whole project, 
// it's included in all generated files.
// JSON string:[{"type":"settings","data":[{"arduino":{"useExportDialog":false,"IOcheckAtExport":true,"WriteJSONtoExportedFile":true,"WebServerPort":8080,"WebSocketServerPort":3000,"ProjectName":"TeensyAudioDesign","StandardIncludeHeader":"#include <Arduino.h>\n#include <Audio.h>\n#include <Wire.h>\n#include <SPI.h>\n#include <SD.h>\n#include <SerialFlash.h>\n"}},{"view":{"showWorkspaceToolbar":true,"showNodeToolTip":true,"space_width":5000,"space_height":5000,"scaleFactor":1,"showGridHminor":true,"showGridHmajor":true,"showGridVminor":true,"showGridVmajor":true,"gridHminorSize":10,"gridHmajorSize":100,"gridVminorSize":10,"gridVmajorSize":100,"gridMinorColor":"#eee","gridMajorColor":"#ddd","snapToGrid":true,"snapToGridHsize":5,"snapToGridVsize":5,"lineCurveScale":0.75,"lineConnectionsScale":1.5}},{"palette":{"categoryHeaderTextSize":12,"categoryHeaderHeight":14,"categoryHeaderBackgroundColor":"#f3f3f3","onlyShowOne":true}}]},{"type":"tab","id":"65451dc5.e7c4b4","label":"LFOSources","inputs":0,"outputs":2,"export":true,"nodes":[]},{"id":"LFONoiseSource_waveform1","type":"AudioSynthWaveform","name":"LFO1","comment":"","x":210,"y":140,"z":"65451dc5.e7c4b4","bgColor":"#E6E0F8","wires":[["LFONoiseSource_Out1:0"]]},{"id":"LFONoiseSource_waveform2","type":"AudioSynthWaveform","name":"LFO2","comment":"","x":210,"y":200,"z":"65451dc5.e7c4b4","bgColor":"#E6E0F8","wires":[["LFONoiseSource_Out2:0"]]},{"id":"LFOSources_vars1","type":"Variables","name":"LFOvars","comment":"// LFO settings\r\nint lfo1Waveform = WAVEFORM_SINE;\r\nfloat lfo1Freq = 0.0;\r\nfloat lfo1Depth = 0.0;\r\nfloat lfo1PWM = 0.0;\r\n\r\nint lfo2Waveform = WAVEFORM_SINE;\r\nfloat lfo2Freq = 0.0;\r\nfloat lfo2Depth = 0.0;\r\nfloat lfo2PWM = 0.0;","x":220,"y":270,"z":"65451dc5.e7c4b4","bgColor":"#DDFFBB","wires":[]},{"id":"LFOSources_ClassComment1","type":"ClassComment","name":"All voices share the same two LFOs","x":315,"y":80,"z":"65451dc5.e7c4b4","bgColor":"#CCFFCC","wires":[]},{"id":"LFONoiseSource_Out1","type":"TabOutput","name":"LFO1Out","comment":"","x":435,"y":140,"z":"65451dc5.e7c4b4","bgColor":"#CCE6FF","wires":[]},{"id":"LFONoiseSource_Out2","type":"TabOutput","name":"LFO2Out","comment":"","x":435,"y":200,"z":"65451dc5.e7c4b4","bgColor":"#CCE6FF","wires":[]},{"id":"LFOSources_code1","type":"Function","name":"LFOcode","comment":"void updateLFO1() {\r\n  LFO1.begin(lfo1Waveform);\r\n  LFO1.frequency(lfo1Freq);\r\n  LFO1.amplitude(lfo1Depth);\r\n  LFO1.pulseWidth(lfo1PWM);\r\n}\r\n\r\nvoid updateLFO2() {\r\n  LFO2.begin(lfo2Waveform);\r\n  LFO2.frequency(lfo2Freq);\r\n  LFO2.amplitude(lfo2Depth);\r\n  LFO2.pulseWidth(lfo2PWM);\r\n}\r\n","x":440,"y":270,"z":"65451dc5.e7c4b4","bgColor":"#DDFFBB","wires":[]},{"type":"tab","id":"Main","label":"Voice","inputs":2,"outputs":1,"export":true,"nodes":[]},{"id":"Voice_ClassComment1","type":"ClassComment","name":"A voice has two Osc, Noise and Wavetable. ","x":245,"y":45,"z":"Main","bgColor":"#CCFFCC","wires":[]},{"id":"Voice_ClassComment2","type":"ClassComment","name":"Each Osc are modulated by two external LFO.","x":255,"y":75,"z":"Main","bgColor":"#CCFFCC","wires":[]},{"id":"Voice_In1","type":"TabInput","name":"LFOmod1","comment":"","x":275,"y":205,"z":"Main","bgColor":"#CCE6FF","wires":[["Voice_waveformMod1:0"]]},{"id":"Voice_In2","type":"TabInput","name":"LFOmod2","comment":"","x":280,"y":265,"z":"Main","bgColor":"#CCE6FF","wires":[["Voice_waveformMod2:0"]]},{"id":"Voice_vars1","type":"Variables","name":"Voicevars","comment":"// modulator settings\r\nint osc1Waveform = WAVEFORM_SINE;\r\nfloat osc1Amplitude = 1.0;\r\nint osc1Octave = 0;\r\nint osc1Semis = 0;\r\nfloat osc1Detune = 1.0; // can range 1.0 to 0.85\r\nfloat osc1PB = 1.0;\r\nosc_mod_t osc1Mod = Mod_FM;\r\n\r\nint osc2Waveform = WAVEFORM_SAWTOOTH;\r\nfloat osc2Amplitude = 1.0;\r\nint osc2Octave = 0;\r\nint osc2Semis = 0;\r\nfloat osc2Detune = 1.0; // can range 1.0 to 0.85\r\nfloat osc2PB = 1.0;\r\nosc_mod_t osc2Mod = Mod_FM;\r\n\r\n// noise settings\r\nfloat noiseAmplitude = 1.0;\r\n\r\n// wavetable\r\nint waveInstrument = 0; // piano\r\nfloat waveAmplitude = 1.0;\r\n\r\n// Mixer settings\r\nfloat osc1Amp = 1.0;\r\nfloat osc2Amp = 0.0;\r\nfloat noiseAmp = 0.0;\r\nfloat waveAmp = 0.0;\r\n\r\n// ADSR envelope settings\r\nfloat envAttack = 10.5;\r\nfloat envDecay = 35;\r\nfloat envSustain = 0.5;\r\nfloat envRelease = 300;","x":280,"y":425,"z":"Main","bgColor":"#DDFFBB","wires":[]},{"id":"Voice_ClassComment3","type":"ClassComment","name":"Each voice has it's own ADSR so can be at a unique position in start/stop playing.","x":365,"y":105,"z":"Main","bgColor":"#CCFFCC","wires":[]},{"id":"Voice_waveformMod1","type":"AudioSynthWaveformModulated","name":"VCO1","comment":"","x":450,"y":210,"z":"Main","bgColor":"#E6E0F8","wires":[["Voice_mixer4_1:0"]]},{"id":"Voice_waveformMod2","type":"AudioSynthWaveformModulated","name":"VCO2","comment":"","x":450,"y":270,"z":"Main","bgColor":"#E6E0F8","wires":[["Voice_mixer4_1:1"]]},{"id":"Voice_wavetable1","type":"AudioSynthWavetable","name":"WaveTable","comment":"","x":440,"y":320,"z":"Main","bgColor":"#E6E0F8","wires":[["Voice_mixer4_1:2"]]},{"id":"Voice_pink1","type":"AudioSynthNoisePink","name":"pinkNoise","comment":"","x":445,"y":370,"z":"Main","bgColor":"#E6E0F8","wires":[["Voice_mixer4_1:3"]]},{"id":"Voice_mixer4_1","type":"AudioMixer4","name":"VoiceMixer","comment":"","inputs":"4","x":635,"y":290,"z":"Main","bgColor":"#E6E0F8","wires":[["Voice_envelope1:0"]]},{"id":"Voice_code1","type":"Function","name":"Voicecode","comment":"void updateMix(Mix_change_t change) {\r\n  VoiceMixer.gain(0, osc1Amp);  \r\n  VoiceMixer.gain(1, osc2Amp);\r\n  VoiceMixer.gain(2, waveAmp);\r\n  VoiceMixer.gain(3, noiseAmp);\r\n  updateMixerBars(change);\r\n}\r\n\r\n\r\nvoid updateADSR(ADSR_change_t change) {\r\n  ADSR.attack(envAttack);\r\n  ADSR.decay(envDecay);\r\n  ADSR.sustain(envSustain);\r\n  ADSR.release(envRelease);\r\n  updateADSRBars(change);\r\n}\r\n\r\nvoid updateOsc1() {\r\n  VCO1.begin(osc1Waveform);\r\n  VCO1.amplitude(osc1Amplitude);\r\n  if (osc1Mod == Mod_FM) {\r\n    //TODO: consider allowing freq mod range to be changed\r\n    VCO1.frequencyModulation(12);\r\n  }\r\n  else {\r\n    //TODO: consider allowing phase mod range to be changed\r\n    VCO1.phaseModulation(180);\r\n  }\r\n}\r\n\r\nvoid updateOsc2() {\r\n  VCO2.begin(osc2Waveform);\r\n  VCO2.amplitude(osc2Amplitude);\r\n  if (osc2Mod == Mod_FM) {\r\n    VCO2.frequencyModulation(12);\r\n  }\r\n  else {\r\n    VCO2.phaseModulation(180);\r\n  }\r\n}\r\n\r\nvoid updateNoise() {\r\n  pinkNoise.amplitude(noiseAmplitude);\r\n}\r\n\r\nvoid updateWave() {\r\n  WaveTable.amplitude(waveAmplitude);\r\n  Wavetable.setInstrument(*GMinst[waveInstrument]);\r\n}\r\n","x":615,"y":425,"z":"Main","bgColor":"#DDFFBB","wires":[]},{"id":"Voice_envelope1","type":"AudioEffectEnvelope","name":"ADSR","comment":"","x":790,"y":290,"z":"Main","bgColor":"#E6E0F8","wires":[["Voice_Out1:0"]]},{"id":"Voice_Out1","type":"TabOutput","name":"VoiceOut","comment":"","x":955,"y":290,"z":"Main","bgColor":"#CCE6FF","wires":[]},{"type":"tab","id":"5f997400.dc1cbc","label":"FilterEffects","inputs":1,"outputs":1,"export":true,"nodes":[]},{"id":"Output_In1","type":"TabInput","name":"InMixFilter","comment":"","x":105,"y":200,"z":"5f997400.dc1cbc","bgColor":"#CCE6FF","wires":[["Output_mixer4_1:0","Output_filter1:0"]]},{"id":"FilterEffects_vars1","type":"Variables","name":"Filtervars","comment":"// filter ADSR\r\nfloat filtEnvA = 10.5;\r\nfloat filtEnvD = 35;\r\nfloat filtEnvS = 0.5;\r\nfloat filtEnvR = 300;\r\n\r\n// filter main variables\r\nfilter_band_t filtBand = LPF;\r\nfloat filterFreq = 5000;\r\nfloat filterRes = 2.5;\r\nfloat filtDC = 1.0;\r\nint filtMod = 0;\r\n\r\n// chorus\r\nint chorusVoices;\r\n// Number of samples in each delay line\r\n// Allocate the delay lines for left and right channels\r\nshort delayline[CHORUS_DELAY_LENGTH];\r\n","x":272,"y":482,"z":"5f997400.dc1cbc","bgColor":"#DDFFBB","wires":[]},{"id":"Output_filter1","type":"AudioFilterStateVariable","name":"filter1","comment":"","x":375,"y":250,"z":"5f997400.dc1cbc","bgColor":"#E6E0F8","wires":[["Output_mixer4_1:1"],["Output_mixer4_1:2"],["Output_mixer4_1:3"]]},{"id":"Output_dc1","type":"AudioSynthWaveformDc","name":"dc1","comment":"","x":315,"y":385,"z":"5f997400.dc1cbc","bgColor":"#E6E0F8","wires":[["Output_envelope1:0"]]},{"id":"Output_envelope1","type":"AudioEffectEnvelope","name":"FilterADSR","comment":"","x":445,"y":385,"z":"5f997400.dc1cbc","bgColor":"#E6E0F8","wires":[["Output_amp1:0"]]},{"id":"FilterEffects_code1","type":"Function","name":"Filtercode","comment":"void updateFiltADSR() {\r\n  FilterADSR.attack(filtEnvA);\r\n  FilterADSR.decay(filtEnvD);\r\n  FilterADSR.sustain(filtEnvS);\r\n  FilterADSR.release(filtEnvR);\r\n  dc1.amplitude(filtDC);\r\n  if (filtMod == 0) {\r\n    ModSwitch.gain(0.0);\r\n  }\r\n  else {\r\n    ModSwitch.gain(1.0);\r\n  }\r\n}\r\n\r\nvoid updateFilterBand() {\r\n  switch(filtBand) {\r\n    case FILT_OFF:\r\n      FilterSelect.gain(0, 1.00);\r\n      FilterSelect.gain(1, 0);\r\n      FilterSelect.gain(2, 0);\r\n      FilterSelect.gain(3, 0);\r\n      break;\r\n\r\n    case LPF:\r\n      FilterSelect.gain(0, 0);\r\n      FilterSelect.gain(1, 1.0);\r\n      FilterSelect.gain(2, 0);\r\n      FilterSelect.gain(3, 0);\r\n      break;\r\n\r\n    case BPF:\r\n      FilterSelect.gain(0, 0);\r\n      FilterSelect.gain(1, 0);\r\n      FilterSelect.gain(2, 1.0);\r\n      FilterSelect.gain(3, 0);\r\n      break;\r\n\r\n    case HPF:\r\n      FilterSelect.gain(0, 0);\r\n      FilterSelect.gain(1, 0);\r\n      FilterSelect.gain(2, 0);\r\n      FilterSelect.gain(3, 1.0);\r\n     break;\r\n  }\r\n}\r\n\r\nvoid updateFilter() {\r\n  filter1.frequency(filterFreq);\r\n  filter1.resonance(filterRes);\r\n}\r\n\r\nvoid initChorus() {\r\n  chorusVoices = 0; // off by default\r\n\r\n  // Initialize the effect\r\n  // address of delayline\r\n  // total number of samples in the delay line\r\n  // number of voices in the chorus INCLUDING the original voice\r\n  if(!chorus.begin(delayline, CHORUS_DELAY_LENGTH, 6)) {\r\n    Serial.println(\"AudioEffectChorus - left channel begin failed\");\r\n    while(1);\r\n  }\r\n}\r\n\r\nvoid updateChorus() {\r\n  chorus.voices(chorusVoices);\r\n}","x":470,"y":480,"z":"5f997400.dc1cbc","bgColor":"#DDFFBB","wires":[]},{"id":"Output_mixer4_1","type":"AudioMixer4","name":"FilterSelect","comment":"","inputs":"4","x":585,"y":200,"z":"5f997400.dc1cbc","bgColor":"#E6E0F8","wires":[["Output_chorus1:0"]]},{"id":"Output_amp1","type":"AudioAmplifier","name":"ModSwitch","comment":"","x":595,"y":385,"z":"5f997400.dc1cbc","bgColor":"#E6E0F8","wires":[["Output_filter1:1"]]},{"id":"Output_chorus1","type":"AudioEffectChorus","name":"chorus1","comment":"","x":765,"y":200,"z":"5f997400.dc1cbc","bgColor":"#E6E0F8","wires":[["Output_Out1:0"]]},{"id":"Output_Out1","type":"TabOutput","name":"OutMixFilter","comment":"","x":975,"y":200,"z":"5f997400.dc1cbc","bgColor":"#CCE6FF","wires":[]},{"type":"tab","id":"95654dc9.1fcd9","label":"Arpeggiator","inputs":0,"outputs":0,"export":true,"nodes":[]},{"id":"Arpeggiator_vars1","type":"Variables","name":"Arpvars","comment":"// Arpeggiator\r\narp_mode_t arpMode;\r\nint arpOctave;\r\nfloat arpPeriod;\r\nbool arpLatch;\r\nfloat arpDelay;\r\nbool arpDelayActive;\r\nint arpTranspose;\r\nbyte arpNotes[NumStoredNotes]; \r\nint arpStoreIndex;\r\nint arpPlayIndex;\r\nint arpNumDown;\r\nint arpIncrement;\r\nint arpPlayOctave;\r\nint arpScaleMode;\r\n","x":268,"y":160,"z":"95654dc9.1fcd9","bgColor":"#DDFFBB","wires":[]},{"id":"Arpeggiator_code1","type":"Function","name":"Arpcode","comment":"void sortNotes() {\r\n/* From Wikipedia \r\n *   \r\nprocedure bubbleSort(A : list of sortable items)\r\n    n := length(A)\r\n    repeat\r\n        newn := 0\r\n        for i := 1 to n - 1 inclusive do\r\n            if A[i - 1] > A[i] then\r\n                swap(A[i - 1], A[i])\r\n                newn := i\r\n            end if\r\n        end for\r\n        n := newn\r\n    until n ≤ 1\r\nend procedure\r\n*/\r\n  int newLen;\r\n  int len = arpStoreIndex + 1;\r\n#ifdef DEBUG_SORT  \r\n  Serial.print(\"Input = \");\r\n  for (int i = 0; i < arpStoreIndex; i++) {\r\n    Serial.printf(\"%d \", arpNotes[i]);\r\n  }\r\n  Serial.println();\r\n#endif  \r\n  do {\r\n    newLen = 0;\r\n    \r\n    for (int i = 1; i < (len - 1); i++) {\r\n      if (arpNotes[i - 1] > arpNotes[i]) {\r\n        byte temp = arpNotes[i - 1];\r\n        arpNotes[i - 1] = arpNotes[i];\r\n        arpNotes[i] = temp;\r\n        newLen = i + 1;\r\n      }\r\n    }\r\n    len = newLen;\r\n  } while(len > 1);\r\n}\r\n\r\nvoid init() {\r\n  arpMode = Arp_Off;\r\n  arpLatch = false;\r\n  arpOctave = 0;\r\n  arpPeriod = 1000;\r\n  arpDelay = 0;\r\n  arpTranspose = 0;\r\n}\r\n\r\nvoid update() {\r\n  if (arpMode != Arp_Off) {\r\n    // play Arpeggiator notes\r\n    if (arpStoreIndex != 0) { // any notes in the array to play?\r\n      // are we in a post sequence delay?\r\n      if ((arpDelay != 0) && (arpDelayActive == true)) {\r\n        if (lastMillis > arpPeriod) {\r\n//          Serial.printf(\"Osc off because lasmillis (%lu) beyond arpPeriod (%u)\", lastMillis, arpPeriod);\r\n          oscillatorsOff();\r\n        }\r\n        if (lastMillis > arpDelay) {\r\n          arpDelayActive = false;\r\n          Serial.println(\"Delay stop\");\r\n          lastMillis = 0;\r\n        }\r\n      }\r\n      else if (lastMillis > arpPeriod) {\r\n        byte note2play;\r\n        lastMillis = 0;\r\n        Serial.print(\"[ \");\r\n        for (int i = 0; i < arpStoreIndex; i++) {\r\n          Serial.print(arpNotes[i]);\r\n          if (i == arpPlayIndex) {\r\n            Serial.print('*');\r\n          }\r\n          Serial.print(' ');\r\n        }\r\n        Serial.printf(\"] Octave=%u\\n\", arpPlayOctave);\r\n        note2play = arpNotes[arpPlayIndex] + arpTranspose + (12 * arpPlayOctave);\r\n//        Serial.println(\"Osc off because arpPeriod expired - cancel last playing note\");\r\n        if (arpMode != Arp_Record) {\r\n          oscillatorsOff(); // end previous note\r\n          oscillatorsOn(note2play); // start new note from ARP array\r\n        }\r\n        switch(arpMode) {\r\n          case Arp_Up:\r\n          case Arp_Scale:\r\n            arpPlayIndex++;\r\n            if (arpPlayIndex >= arpStoreIndex) {\r\n              arpPlayIndex = 0;\r\n              if (arpPlayOctave < arpOctave) {\r\n                arpPlayOctave++;\r\n              }\r\n              else {\r\n                arpDelayActive = true;\r\n                arpPlayOctave = 0;\r\n                Serial.println(\"Up: Delay start\");\r\n              }\r\n            }\r\n            break;\r\n          case Arp_Down:\r\n            arpPlayIndex--;\r\n            if (arpPlayIndex < 0) {\r\n              arpPlayIndex = arpStoreIndex - 1;\r\n              if (arpPlayOctave > 0) {\r\n                arpPlayOctave--;\r\n              }\r\n              else {\r\n                arpDelayActive = true;\r\n                arpPlayOctave = arpOctave;\r\n                Serial.println(\"Dn: Delay start\");\r\n              }\r\n            }\r\n            break;\r\n          case Arp_UpDown:\r\n            arpPlayIndex += arpIncrement;\r\n            if (arpPlayIndex >= arpStoreIndex) {\r\n              if (arpPlayOctave < arpOctave) {\r\n                arpPlayOctave++;\r\n                arpPlayIndex = 0;\r\n              }\r\n              else {\r\n                arpPlayIndex--;\r\n                arpIncrement = -arpIncrement;\r\n                arpDelayActive = true;\r\n                Serial.println(\"Up*: Delay start\");\r\n              }\r\n            }\r\n            if (arpPlayIndex < 0) {\r\n              if (arpPlayOctave > 0) {\r\n                arpPlayOctave--;\r\n                arpPlayIndex = arpStoreIndex - 1;\r\n              }\r\n              else {\r\n                arpPlayIndex++;\r\n                arpIncrement = -arpIncrement;\r\n                arpDelayActive = true;\r\n                Serial.println(\"Dn*: Delay start\");\r\n              }\r\n            }\r\n            break;\r\n         case Arp_Random:\r\n            arpPlayIndex = rand() % arpStoreIndex;\r\n            if (arpOctave > 0) {\r\n              arpPlayOctave = rand() % (arpOctave + 1);\r\n            }\r\n            else {\r\n              arpPlayOctave = 0;\r\n            }\r\n            break;\r\n        }\r\n      }\r\n    }\r\n  }\r\n}","x":459,"y":160,"z":"95654dc9.1fcd9","bgColor":"#DDFFBB","wires":[]},{"type":"tab","id":"8ff6bbec.7eceb8","label":"ContinuousController","inputs":0,"outputs":0,"export":true,"nodes":[]},{"id":"ContinuousController_code1","type":"Function","name":"CCcode","comment":"void OnControlChange(byte channel, byte control /* CC num*/, byte value /* 0 .. 127 */) {\r\n  int n;\r\n  Serial.printf(\"CC: %u = %u ==> \", control, value);\r\n  switch(control) {\r\n    case 1:\r\n      Serial.println(\"Mod wheel\");\r\n      break;\r\n    // ====================== MIXER =====================\r\n    case 75:\r\n      osc1Amp =  velocity2amplitude[value];\r\n      Serial.printf(\"Mix: Osc1 amplitude = %.2f\\n\", osc1Amp);\r\n      updateMix(OSC1);\r\n      break;\r\n\r\n    case 76:\r\n      osc2Amp = velocity2amplitude[value];\r\n      Serial.printf(\"Mix: Osc2 amplitude = %.2f\\n\", osc2Amp);\r\n      updateMix(OSC2);\r\n      break;\r\n\r\n    case 77:\r\n      waveAmp = velocity2amplitude[value];\r\n      Serial.printf(\"Mix: Wavetable amplitude = %.2f\\n\", waveAmp);\r\n      updateMix(WaveTable);\r\n      break;\r\n\r\n    case 102:\r\n      noiseAmp = velocity2amplitude[value];\r\n      Serial.printf(\"Mix: Noise amplitude = %.2f\\n\", noiseAmp);\r\n      updateMix(Noise);\r\n      break;\r\n\r\n    // ======================== Amp ADSR ==========================\r\n    case 103:\r\n      envAttack = mapf(value, 0, 127, 0.0, 3000.0);\r\n      Serial.printf(\"Attack = %.2f\\n\", envAttack);\r\n      updateADSR(Attack);\r\n      break;\r\n\r\n    case 104:\r\n      envDecay = mapf(value, 0, 127, 0.0, 3000.0);\r\n      Serial.printf(\"Decay = %.2f\\n\", envDecay);\r\n      updateADSR(Decay);\r\n      break;\r\n\r\n    case 105:\r\n      envSustain = mapf(value, 0, 127, 0.0, 1.0);\r\n      Serial.printf(\"Sustain = %.2f\\n\", envSustain);\r\n      updateADSR(Sustain);\r\n      break;\r\n\r\n    case 106:\r\n      envRelease = mapf(value, 0, 127, 0.0, 3000.0);\r\n      Serial.printf(\"Release = %.2f\\n\", envRelease);\r\n      updateADSR(Release);\r\n      break;\r\n\r\n    // ========================= FILTER =======================\r\n    case 107:\r\n      value /= 20;\r\n      if (value == 0) {\r\n        filtBand = FILT_OFF;\r\n      }\r\n      else if (value == 1) {\r\n        filtBand= LPF;\r\n      }\r\n      else if (value = 2) {\r\n        filtBand= BPF;\r\n      }\r\n      else {\r\n        filtBand = HPF;\r\n      }\r\n      Serial.printf(\"Filter band = %s\\n\", bands[filtBand]);\r\n      updateFilterBand();\r\n      break;\r\n\r\n    case 108:\r\n      filterFreq = mapf(value, 0, 127, 0, 10000);\r\n      Serial.printf(\"Filter Freq = %.2fHz\\n\", filterFreq);\r\n      updateFilter();\r\n      break;\r\n\r\n    case 109:\r\n      filterRes = mapf(value, 0, 127, 0.7, 5.0);\r\n      Serial.printf(\"Resonance = %.2f\\n\", filterRes);\r\n      updateFilter();\r\n      break;\r\n\r\n    // =================== WAVE SHAPE ======================\r\n    case 110:\r\n    case 111:\r\n    case 116:\r\n    case 117:\r\n      int change;\r\n      value /= 10;\r\n      switch (value) {\r\n        case 0:\r\n          // nothing for now as it'll be used to disable source below\r\n          break;\r\n        case 1:\r\n        default:\r\n          change = WAVEFORM_SINE;\r\n          break;\r\n        case 2:\r\n          change = WAVEFORM_SAWTOOTH;\r\n          break;\r\n        case 3:\r\n          change = WAVEFORM_SAWTOOTH_REVERSE;\r\n          break;\r\n        case 4:\r\n          change = WAVEFORM_SQUARE;\r\n          break;\r\n        case 5:\r\n          change = WAVEFORM_TRIANGLE;\r\n          break;\r\n        case 6:\r\n          change = WAVEFORM_SAMPLE_HOLD;\r\n          break;\r\n        case 7:\r\n          change = WAVEFORM_ARBITRARY;\r\n          break;\r\n        case 8:\r\n          change = WAVEFORM_PULSE;\r\n          break;\r\n      }\r\n      Serial.printf(\"Wave: %s (\", (value == 0) ? \"Off\" : waves[change]);\r\n      if (control == 110) {\r\n        Serial.println(\"LFO1)\");\r\n        if (value == 0) {\r\n          LFO1switch.gain(0);          \r\n        }\r\n        else {\r\n          LFO1switch.gain(1.0);\r\n          lfo1Waveform = change;\r\n          updateLFO1();\r\n        }\r\n      }\r\n      if (control == 111) {\r\n        Serial.println(\"LFO2)\");\r\n        if (value == 0) {\r\n          LFO2switch.gain(0);\r\n        }\r\n        else {\r\n          LFO2switch.gain(1.0);\r\n          lfo2Waveform = change;\r\n          updateLFO2();\r\n        }\r\n      }\r\n      if (control == 116) {\r\n        Serial.println(\"OSC1)\");\r\n        if (value == 0) {\r\n          Osc1switch.gain(0);\r\n        }\r\n        else {\r\n          Osc1switch.gain(1.0);\r\n          osc1Waveform = change;\r\n          updateOsc1();\r\n        }\r\n      }\r\n      if (control == 117) {\r\n        Serial.println(\"OSC2)\");\r\n        if (value == 0) {\r\n          Osc2switch.gain(0);\r\n        }\r\n        else {\r\n          Osc2switch.gain(1.0);\r\n          osc2Waveform = change;\r\n          updateOsc2();\r\n        }\r\n      }\r\n      break;\r\n\r\n    // ===========================  LFO1 =====================\r\n    case 112:\r\n      if (value < 64) {\r\n        lfo1Freq = mapf(value, 0, 64, 0.0, 20.0);        \r\n      }\r\n      else {\r\n        lfo1Freq = mapf(value, 64, 127, 20.0, 200.0);\r\n      }\r\n      Serial.printf(\"LFO1 freq = %.2fHz\\n\", lfo1Freq);\r\n      updateLFO1();\r\n      break;\r\n\r\n    case 114:\r\n      lfo1Depth = mapf(value, 0, 127, 0.0, 0.2);\r\n      Serial.printf(\"LFO1 depth = %.2f\\n\", lfo1Depth);\r\n      updateLFO1();\r\n      break;\r\n\r\n    case 20:\r\n      lfo1PWM = mapf(value, 0, 127, 0.0, 1.0);\r\n      Serial.printf(\"LFO1 PWM = %.2f\\n\", lfo1PWM);\r\n      updateLFO1();\r\n      break;\r\n\r\n    // ===================== LFO2 ========================\r\n    case 113:\r\n      if (value < 64) {\r\n        lfo2Freq = mapf(value, 0, 64, 0.0, 20.0);        \r\n      }\r\n      else {\r\n        lfo2Freq = mapf(value, 64, 127, 20.0, 200.0);\r\n      }\r\n      Serial.printf(\"LFO2 freq = %.2fHz\\n\", lfo2Freq);\r\n      updateLFO2();\r\n      break;\r\n\r\n    case 115:\r\n      lfo2Depth = mapf(value, 0, 127, 0.0, 0.2);\r\n      Serial.printf(\"LFO2 depth = %.2f\\n\", lfo2Depth);\r\n      updateLFO2();\r\n      break;\r\n\r\n    case 21:\r\n      lfo2PWM = mapf(value, 0, 127, 0.0, 1.0);\r\n      Serial.printf(\"LFO2 PWM = %.2f\\n\", lfo2PWM);\r\n      updateLFO2();\r\n      break;\r\n\r\n    // ======================= OSC1 =======================\r\n    case 118:\r\n      osc1Semis = mapf(value, 0.0, 127, 0, 12);\r\n      Serial.printf(\"Osc1 semis = %u\\n\", osc1Semis);\r\n      updateOsc1();\r\n      break;\r\n\r\n    case 23:\r\n      value = (value > 48) ? 48 : value;\r\n      n = (value / 12) * 12;\r\n      osc1Octave = n - 24;\r\n      Serial.printf(\"Osc1 Octave: %d\\n\", osc1Octave);\r\n      break;\r\n\r\n    case 25:\r\n      osc1Detune = mapf(value, 0, 127, 1.0, 0.85);\r\n      Serial.printf(\"Osc1 detune = %.2f\\n\", osc1Detune);\r\n      break;\r\n\r\n    case 14:\r\n      Serial.printf(\"Osc1 modulation = %s\\n\", value == 0 ? \"FM\" : \"PM\");\r\n      // 0..63 = FM, 64..127 = PM\r\n      if (value < 64) {\r\n        osc1Mod = Mod_FM;\r\n      }\r\n      else {\r\n        osc1Mod = Mod_PM;\r\n      }\r\n      break;\r\n\r\n    // ======================= OSC2 ============================\r\n    case 119:\r\n      osc2Semis = mapf(value, 0, 127, 0.0, 12);\r\n      Serial.printf(\"Osc2 semis = %u\\n\", osc2Semis);\r\n      updateOsc2();\r\n      break;\r\n\r\n    case 26:\r\n      value = (value > 48) ? 48 : value;\r\n      n = (value / 12) * 12;\r\n      osc2Octave = n - 24;\r\n      Serial.printf(\"Osc2 Octave: %d\\n\", osc2Octave);\r\n      break;\r\n\r\n    case 27:\r\n      osc2Detune = mapf(value, 0, 127, 1.0, 0.85);\r\n      Serial.printf(\"Osc2 detune = %.2f\\n\", osc2Detune);\r\n      break;\r\n\r\n    case 15:\r\n      Serial.printf(\"Osc2 modulation = %s\\n\", value == 0 ? \"FM\" : \"PM\");\r\n      // 0..63 = FM, 64..127 = PM\r\n      if (value < 64) {\r\n        osc2Mod = Mod_FM;\r\n      }\r\n      else {\r\n        osc2Mod = Mod_PM;\r\n      }\r\n      break;\r\n\r\n    // ======================== Filter ADSR =======================\r\n    case 22:\r\n      filtEnvA = mapf(value, 0, 127, 0.0, 3000.0);\r\n      Serial.printf(\"Filter Attack = %.2f\\n\", filtEnvA);\r\n      updateFiltADSR();\r\n      break;\r\n\r\n    case 24:\r\n      filtEnvD = mapf(value, 0, 127, 0.0, 3000.0);\r\n      Serial.printf(\"Filter Decay = %.2f\\n\", filtEnvD);\r\n      updateFiltADSR();\r\n      break;\r\n\r\n    case 28:\r\n      filtEnvS = mapf(value, 0, 127, 0.0, 1.0);\r\n      Serial.printf(\"Filter Sustain = %.2f\\n\", filtEnvS);\r\n      updateFiltADSR();\r\n      break;\r\n\r\n    case 29:\r\n      filtEnvR = mapf(value, 0, 127, 0.0, 3000.0);\r\n      Serial.printf(\"Filter Release = %.2f\\n\", filtEnvR);\r\n      updateFiltADSR();\r\n      break;\r\n\r\n    // ====================== FILTER ====================\r\n    case 30:\r\n      filtDC = mapf(value, 0, 127, -1.0, 1.0);\r\n      Serial.printf(\"DC = %.2f\\n\", filtDC);\r\n      updateFiltADSR();\r\n      break;\r\n\r\n    case 31:\r\n      // use amp as a 0/1 switch for filter DC modulation\r\n      filtMod = (value < 64) ? 0 : 1;\r\n      Serial.printf(\"Modulation = %d\\n\", filtMod);\r\n      updateFiltADSR();\r\n      if (filtMod == 0) {\r\n        dumpPatch();\r\n      }\r\n      break;\r\n\r\n    // ===================== ARPEGGIATOR ===================\r\n    case 85:\r\n      value /= 20;\r\n      value *= 20;\r\n      if (value == 0) {\r\n        arpMode = Arp_Off;\r\n        Serial.println(\"Arp Off - Osc Off\");\r\n        oscillatorsOff();\r\n        arpStoreIndex = 0;\r\n        arpPlayIndex = 0;\r\n      }\r\n      else if (value == 20) {\r\n        arpMode = Arp_Up;\r\n        Serial.println(\"Arp Up\");\r\n        arpPlayIndex = 0;\r\n        arpDelayActive = false;\r\n        arpPlayOctave = 0;\r\n      }\r\n      else if (value == 40) {\r\n        arpMode = Arp_Down;\r\n        Serial.println(\"Arp Down\");\r\n        arpPlayIndex = 0;\r\n        arpDelayActive = false;\r\n        arpPlayOctave = arpOctave;\r\n      }\r\n      else if (value == 60) {\r\n        arpMode = Arp_UpDown;\r\n        Serial.println(\"Arp Up/Down\");\r\n        arpPlayIndex = 0;\r\n        arpIncrement = 1; // start \"up\"\r\n        arpDelayActive = false;\r\n        arpPlayOctave = 0;\r\n      }\r\n      else if (value == 80) {\r\n        arpMode = Arp_Random;\r\n        Serial.println(\"Arp Random\");\r\n      }\r\n      else if (value == 100) {\r\n        Serial.println(\"Arp Scales\");\r\n        arpMode = Arp_Scale;\r\n        arpPlayIndex = 0;\r\n        arpDelayActive = false;\r\n        arpPlayOctave = 0;\r\n      }\r\n      else if (value == 120) {\r\n        Serial.println(\"Arp Record\");\r\n        arpMode = Arp_Record;\r\n        arpStoreIndex = 0;\r\n        arpPlayIndex = 0;\r\n        arpDelayActive = false;\r\n        arpPlayOctave = 0;\r\n      }\r\n      break;\r\n\r\n    case 86:\r\n      arpOctave = (value / 20);\r\n      Serial.printf(\"Arp Octaves = %d\\n\", arpOctave + 1);\r\n      break;\r\n\r\n    case 87:\r\n      arpLatch = (value >= 64) ? 1 : 0; // 0 /1\r\n      if (value == 0) {\r\n        arpPlayIndex = 0;\r\n        arpStoreIndex = 0;\r\n        arpPlayOctave = 0;\r\n//        Serial.println(\"Osc off because latch Off\");\r\n        oscillatorsOff();\r\n      }\r\n      Serial.printf(\"Arp Latch = %u\\n\", arpLatch);\r\n      break;\r\n\r\n    case 88:\r\n      arpPeriod = mapf(value, 0, 127, 1200, 50); // not sure of units yet\r\n      Serial.printf(\"Arp Period = %.2f\\n\", arpPeriod);\r\n      break;\r\n\r\n    case 89:\r\n      arpDelay = mapf(value, 0, 127, 0, 2000);\r\n      Serial.printf(\"Arp Delay = %.2f\\n\", arpDelay);\r\n      break;\r\n\r\n    case 90:\r\n      arpTranspose = (int)mapf(value, 0, 127, 0, 11);\r\n      Serial.printf(\"Arp Transpose = %u\\n\", arpTranspose);\r\n      break;\r\n\r\n    case 92:\r\n      arpScaleMode = value;\r\n      Serial.printf(\"Scale = %s\\n\", scaleModes[value].name);\r\n      break;\r\n\r\n    // ===================== CHORUS ====================\r\n    case 91:\r\n      value /= 20;\r\n      value *= 20;\r\n      if (value == 0) {\r\n        chorusVoices = 0;\r\n      }\r\n      else if (value == 20) {\r\n        chorusVoices = 2;\r\n      }\r\n      else if (value == 40) {\r\n        chorusVoices = 4;\r\n      }\r\n      else if (value == 60) {\r\n        chorusVoices = 6;\r\n      }\r\n      Serial.printf(\"Chorus = %u\\n\", chorusVoices);\r\n      updateChorus();\r\n      break;\r\n\r\n    // ========================= PANIC =================\r\n    case 123:\r\n      // MIDI PANIC!!\r\n      arpPlayIndex = 0;\r\n      arpStoreIndex = 0;\r\n      arpPlayOctave = 0;\r\n      arpLatch = 0;\r\n      Serial.println(\"Osc off because Panic\");\r\n      oscillatorsOff();\r\n      break;\r\n\r\n    default:\r\n      // if unrecognised do nothing\r\n      break;\r\n  }\r\n}\r\n","x":454,"y":182,"z":"8ff6bbec.7eceb8","bgColor":"#DDFFBB","wires":[]},{"type":"tab","id":"312a4458.4253ec","label":"PitchBend","inputs":0,"outputs":0,"export":true,"nodes":[]},{"id":"PitchBend_code1","type":"Function","name":"PBcode","comment":"void onPitchChange(byte channel, int pitch) {\r\n  float change = 0.0;\r\n  Serial.printf(\"Pitch change: %d\\n\", pitch);\r\n  if (pitch == 0) {\r\n    osc1PB = 1.0;\r\n    osc2PB = 1.0;\r\n  }\r\n  else {\r\n    // pitch is -8192 to +8192 so convert that to -0.5 to +0.5\r\n    change = (0.5 / 8192) * pitch;\r\n    // so swing from 0.5 to 1.5\r\n    osc1PB = 1.0 + change;\r\n    osc2PB = 1.0 + change;\r\n  }\r\n  Serial.printf(\"Pitch change: %d so bend = %.05f, osc1PB = %.02f, osc2PB = %.02f\\n\", pitch, change, osc1PB, osc2PB);\r\n  if (arpNumDown != 0) {\r\n    // something already playing so retrigger with new freq\r\n    oscillatorsOn();\r\n  }\r\n}\r\n","x":390,"y":156,"z":"312a4458.4253ec","bgColor":"#DDFFBB","wires":[]},{"type":"tab","id":"f32e2e0a.d7803","label":"NoteHandling","inputs":0,"outputs":0,"export":true,"nodes":[]},{"id":"NoteHandling_code1","type":"Function","name":"Notecode","comment":"void OnNoteOn(byte channel, byte note, byte velocity) {\r\n  Serial.printf(\"ch: %u, note: %u, vel: %u \", channel, note, velocity);\r\n  digitalWrite(LED_PIN, HIGH);\r\n  if (note >= 48) {\r\n    highlightKey(note, true);\r\n  }\r\n  arpNumDown++;\r\n  if (arpMode == Arp_Off) {\r\n    oscillatorsOn(note);\r\n  }\r\n  else if (arpStoreIndex < 20) {\r\n    Serial.println(); // finish note info logging\r\n    // just consider adding notes to be played to the Arp array\r\n\r\n    if ((arpMode == Arp_Scale) && (arpStoreIndex != 0)) {\r\n      // already playing a scale so clear all notes to allow\r\n      // new one to be added\r\n      arpStoreIndex = 0;\r\n      arpPlayIndex = 0;\r\n      arpPlayOctave = 0;\r\n    }\r\n\r\n    // usually just add one note to the sequence\r\n    arpNotes[arpStoreIndex] = note;\r\n    Serial.printf(\"Added note %u at entry %u\\n\", note, arpStoreIndex);\r\n    arpStoreIndex++;\r\n\r\n    // but want a whole scale if in scale mode...\r\n    if (arpMode == Arp_Scale) {\r\n      int currNote = note;\r\n      // but if Scale mode add all the other notes of this scale...\r\n      for (int n = 0; n < scaleModes[arpScaleMode].entries; n++) {\r\n        currNote += scaleModes[arpScaleMode].offsets[n];\r\n        arpNotes[arpStoreIndex++] = currNote;\r\n      }\r\n    }\r\n    if (arpMode != Arp_Record) {\r\n      sortNotes();\r\n    }\r\n    else {\r\n      // in record mode we simply record everything played in order (no sort)\r\n      Serial.printf(\"Playing %u while recording\\n\", note);\r\n      oscillatorsOn(note);\r\n    }\r\n  }\r\n}\r\n\r\nvoid OnNoteOff(byte channel, byte note, byte velocity) {\r\n  if (note >= 48) {\r\n    highlightKey(note, false);\r\n  }\r\n  digitalWrite(LED_PIN, LOW);\r\n  arpNumDown--;\r\n  if (!arpLatch) {\r\n    // remove the off note from the array\r\n    for (int i = 0; i < arpStoreIndex; i++) {\r\n      if (arpNotes[i] == note) {\r\n        // shuffle remaining back 1 to this slot\r\n        for (int j = i + 1; j < arpStoreIndex; j++) {\r\n          arpNotes[j - 1] = arpNotes[j];\r\n        }\r\n        // and reduce number in array.\r\n        arpStoreIndex--;\r\n        break;\r\n      }\r\n    }\r\n  }\r\n//  Serial.println(\"Osc off because NoteOff\");\r\n  oscillatorsOff();\r\n}\r\n","x":325,"y":104,"z":"f32e2e0a.d7803","bgColor":"#DDFFBB","wires":[]},{"type":"tab","id":"5d3343db.fec47c","label":"Synth","inputs":0,"outputs":0,"export":true,"nodes":[]},{"id":"Synth_includeDef1","type":"IncludeDef","name":"\"types.h\"","comment":"","x":140,"y":50,"z":"5d3343db.fec47c","bgColor":"#DDFFBB","wires":[]},{"id":"Synth_includeDef2","type":"IncludeDef","name":"\"constdata.h\"","comment":"","x":155,"y":85,"z":"5d3343db.fec47c","bgColor":"#DDFFBB","wires":[]},{"id":"Synth_includeDef3","type":"IncludeDef","name":"\"notedata.h\"","comment":"","x":150,"y":120,"z":"5d3343db.fec47c","bgColor":"#DDFFBB","wires":[]},{"id":"Synth_includeDef4","type":"IncludeDef","name":"\"gminst.h\"","comment":"","x":145,"y":155,"z":"5d3343db.fec47c","bgColor":"#DDFFBB","wires":[]},{"id":"Synth_LFOSources1","type":"LFOSources","name":"LFOSources1","x":115,"y":390,"z":"5d3343db.fec47c","bgColor":"#ccffcc","wires":[["Synth_Voice1:0"],["Synth_Voice1:1"]]},{"id":"Synth_constValue1","type":"ConstValue","name":"NumStoredNotes","value":"32","valueType":"int","x":145,"y":595,"z":"5d3343db.fec47c","bgColor":"#EB9834","wires":[]},{"id":"Synth_Voice1","type":"Voice","name":"Voice[8]","x":345,"y":390,"z":"5d3343db.fec47c","bgColor":"#CCFFCC","wires":[["Synth_mixer1:0"]]},{"id":"Synth_vars1","type":"Variables","name":"Synthvars","comment":"int clickCount = 0;\r\nelapsedMillis lastMillis = 0;\r\nelapsedMillis last_time = 0;\r\nlong encPos = -999;\r\nint encVal = 0;\r\n\r\n// Use hardware SPI (on Uno, #13, #12, #11) and the above for CS/DC\r\nILI9341_t3 tft = ILI9341_t3(TFT_CS, TFT_DC);\r\nXPT2046_Touchscreen ts(TOUCH_CS);\r\nEncoder enc(2,3);\r\nMIDI_CREATE_INSTANCE(HardwareSerial, Serial1, MIDI);\r\n\r\nbyte currentNote;\r\n","x":340,"y":600,"z":"5d3343db.fec47c","bgColor":"#DDFFBB","wires":[]},{"id":"Synth_mixer1","type":"AudioMixer","name":"MixVoices","inputs":"1","comment":"","x":545,"y":390,"z":"5d3343db.fec47c","bgColor":"#E6E0F8","wires":[["Synth_FilterEffects1:0"]]},{"id":"Synth_code1","type":"Function","name":"Synthcode","comment":"void dumpPatch() {\r\n  Serial.println(\"====================================\");\r\n  Serial.printf( \"OSC1: wave=%s, ampl=%.2f, octave=%d, semis=%u, detune=%.2f\\n\",\r\n                  waves[osc1Waveform], osc1Amplitude, osc1Octave, osc1Semis, osc1Detune);\r\n  Serial.printf( \"LFO1: wave=%s, freq=%.2fHz, depth=%.2f, PWM=%.2f\\n\\n\",\r\n                  waves[lfo1Waveform], lfo1Freq, lfo1Depth, lfo1PWM);\r\n  Serial.printf( \"OSC2: wave=%s, ampl=%.2f, octave=%d, semis=%u, detune= %.2f\\n\",\r\n                  waves[osc2Waveform], osc2Amplitude, osc2Octave, osc2Semis, osc2Detune);\r\n  Serial.printf( \"LFO2: wave=%s, freq=%.2fHz, depth=%.2f, PWM=%.2f\\n\\n\",\r\n                  waves[lfo2Waveform], lfo2Freq, lfo2Depth, lfo2PWM);\r\n  Serial.printf( \"Filter: band=%s, freq=%.2fHz, res=%.2f, DC=%.2f, modulated=%u\\n\\n\",\r\n                  bands[filtBand], filterFreq, filterRes, filtDC, filtMod);\r\n  Serial.printf( \"Mix ADSR: attack=%.2f, decay=%.2f, sustain=%.2f, release=%.2f\\n\",\r\n                  envAttack, envDecay, envSustain, envRelease);\r\n  Serial.printf( \"Filter ADSR: attack=%.2f, decay=%.2f, sustain=%.2f, release=%.2f\\n\\n\",\r\n                  filtEnvA, filtEnvD, filtEnvS, filtEnvR);\r\n  Serial.printf( \"Mixer: osc1=%.2f, osc2=%.2f, noise=%.2f, wavetab=%.2f\\n\\n\",\r\n                  osc1Amp, osc2Amp, noiseAmp, waveAmp);\r\n  Serial.printf( \" Arpeggiator: arpMode=%s, arpPeriod=%.2f, arpOctave=%u, arpLatch=%u, arpDelay=%.2f, arpTranspose=%d\\n\",\r\n                  arpModes[arpMode], arpPeriod, arpOctave, arpLatch, arpDelay, arpTranspose);\r\n  Serial.println(\"====================================\");\r\n}\r\n\r\ndouble mapf(double x, double in_min, double in_max, double out_min, double out_max)\r\n{\r\n    return (x - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;\r\n}\r\n\r\n\r\nvoid oscillatorsOn() {\r\n  oscillatorsOn(currentNote);\r\n}\r\n\r\nvoid oscillatorsOn(byte playNote) {\r\n  currentNote = playNote; // in case we need to retrigger after recalculating pitch bend\r\n  \r\n  byte note;\r\n  note = playNote;  \r\n\r\n  note += osc1Octave; // -24, -12, 0, 12 or 24\r\n  note += osc1Semis;\r\n  if (note < 0) {\r\n    note = 0;\r\n  }\r\n  if (note > 127) {\r\n    note = 127;\r\n  }\r\n  Serial.printf(\"Osc1 note=%d (%s%u) \", note, noteNames[note %12], (note / 12) - 1);\r\n  float freq = tune_frequencies2_PGM[note];\r\n  freq *= osc1Detune; // mult 0.85 .. 1.0\r\n  freq *= osc1PB;\r\n  Serial.printf(\"so freq1 = %.2fHz, \", freq);\r\n  waveformMod1.frequency(freq);\r\n\r\n  wavetable1.playFrequency(freq, 127);\r\n\r\n  note = playNote;\r\n  note += osc2Octave; // -24, -12, 0, 12 or 24\r\n  note += osc2Semis;\r\n  if (note < 0) {\r\n    note = 0;\r\n  }\r\n  if (note > 127) {\r\n    note = 127;\r\n  }\r\n  Serial.printf(\"Osc2 note=%d (%s%u) \", note, noteNames[note %12], (note / 12) - 1);\r\n  freq = tune_frequencies2_PGM[note];\r\n  freq *= osc2Detune; // mult 0.85 .. 1.0\r\n  freq *= osc2PB;\r\n  Serial.printf(\"freq2 = %.2fHz\\n\", freq);\r\n  waveformMod2.frequency(freq);\r\n  // sound ADSR\r\n  envelope1.noteOn();\r\n  // filter ADSR\r\n  envelope2.noteOn();\r\n//  Serial.println(\"Both Env triggered\");\r\n}\r\n\r\nvoid oscillatorsOff() {\r\n  envelope1.noteOff();\r\n  envelope2.noteOff();\r\n  wavetable1.stop();\r\n}\r\n\r\nvoid onProgramChange(byte channel, byte program) {\r\n  waveInstrument = program & 0x7F; // currently so limit 0..127\r\n  Serial.printf(\"Progran change: %u = %s\\n\", waveInstrument, instrumentNames[waveInstrument]);\r\n  updateWave();\r\n}\r\n\r\nvoid init() {\r\n  pinMode(LED_PIN, OUTPUT);\r\n  pinMode(JOY_SW, INPUT_PULLUP);\r\n  Serial.begin(9600);\r\n  Serial1.begin(31250);\r\n  Serial.println(\"The bastard is Alive!\");\r\n  MIDI.begin();\r\n  ts.begin();\r\n  ts.setRotation(3);\r\n  tftInit(); \r\n  AudioMemory(20);\r\n  sgtl5000_1.enable();\r\n  sgtl5000_1.volume(0.75);\r\n  updateOsc1();\r\n  updateOsc2();\r\n  updateNoise(); // this probably fixed at 1.0 (mixer varies level)\r\n  updateLFO1();\r\n  updateLFO2();\r\n  updateWave();\r\n  updateMix(AllMix);\r\n  updateADSR(AllADSR);\r\n  updateFiltADSR();\r\n  updateFilterBand();\r\n  updateFilter();\r\n  initChorus();\r\n  updateChorus();\r\n  arp.init();\r\n  usbMIDI.setHandleNoteOff(OnNoteOff);\r\n  usbMIDI.setHandleNoteOn(OnNoteOn);\r\n  usbMIDI.setHandleControlChange(OnControlChange);\r\n  usbMIDI.setHandlePitchChange(onPitchChange);\r\n  usbMIDI.setHandleProgramChange(onProgramChange);\r\n\r\n  MIDI.setHandleNoteOff(OnNoteOff);\r\n  MIDI.setHandleNoteOn(OnNoteOn);\r\n  MIDI.setHandleControlChange(OnControlChange);\r\n  MIDI.setHandlePitchBend(onPitchChange);\r\n  MIDI.setHandleProgramChange(onProgramChange);\r\n}\r\n\r\nvoid update() {\r\n  // put your main code here, to run repeatedly:\r\n  usbMIDI.read();\r\n  MIDI.read()\r\n\r\n#ifdef USE_TOUCH\r\n  if (ts.touched()) {\r\n    int X, Y;\r\n    TS_Point p = ts.getPoint();\r\n    X = p.x - 231;\r\n    X = map(X, 3482, 0, 0, 320);\r\n    Y = p.y - 360;\r\n    Y = map(Y, 3465, 0, 0, 240);\r\n    tft.setFont(Arial_14);\r\n    tft.fillRect(240, 5, 100, 30, ILI9341_BLACK);\r\n    tft.setTextColor(ILI9341_RED);\r\n    tft.setCursor(240, 5);\r\n    int Aval;\r\n    Aval = pointInBar(X, Y, ADSR_PANEL_X + 5, ADSR_PANEL_Y);\r\n    if (Aval > 0) {\r\n      tft.print(Aval);\r\n      OnControlChange(1, 103, Aval);\r\n    }\r\n    int Dval;\r\n    Dval = pointInBar(X, Y, ADSR_PANEL_X + 30, ADSR_PANEL_Y);\r\n    if (Dval > 0) {\r\n      tft.print(Dval);\r\n      OnControlChange(1, 104, Dval);\r\n    }\r\n    int Sval;\r\n    Sval = pointInBar(X, Y, ADSR_PANEL_X + 55, ADSR_PANEL_Y);\r\n    if (Sval > 0) {\r\n      tft.print(Sval);\r\n      OnControlChange(1, 105, Sval);\r\n    }\r\n    int Rval;\r\n    Rval = pointInBar(X, Y, ADSR_PANEL_X + 80, ADSR_PANEL_Y);\r\n    if (Rval > 0) {\r\n      tft.print(Rval);\r\n      OnControlChange(1, 106, Rval);\r\n    }\r\n    int O1val;\r\n    O1val = pointInBar(X, Y, MIX_PANEL_X + 5, MIX_PANEL_Y);\r\n    if (O1val > 0) {\r\n      tft.print(O1val);\r\n      OnControlChange(1, 100, O1val);\r\n    }\r\n    int O2val;\r\n    O2val = pointInBar(X, Y, MIX_PANEL_X + 30, MIX_PANEL_Y);\r\n    if (O2val > 0) {\r\n      tft.print(O2val);\r\n      OnControlChange(1, 101, O2val);\r\n    }\r\n    int Nval;\r\n    Nval = pointInBar(X, Y, MIX_PANEL_X + 55, MIX_PANEL_Y);\r\n    if (Nval > 0) {\r\n      tft.print(Nval);\r\n      OnControlChange(1, 102, Nval);\r\n    }\r\n  }\r\n  #endif\r\n\r\n  arp.update();\r\n  if(0) {\r\n    if(last_time >= 5000) {\r\n      Serial.print(\"Proc = \");\r\n      Serial.print(AudioProcessorUsage());\r\n      Serial.print(\" (\");    \r\n      Serial.print(AudioProcessorUsageMax());\r\n      Serial.print(\"),  Mem = \");\r\n      Serial.print(AudioMemoryUsage());\r\n      Serial.print(\" (\");    \r\n      Serial.print(AudioMemoryUsageMax());\r\n      Serial.println(\")\");\r\n      last_time = 0;\r\n    }\r\n  }\r\n}\r\n","x":520,"y":600,"z":"5d3343db.fec47c","bgColor":"#DDFFBB","wires":[]},{"id":"Synth_sgtl5000_1","type":"AudioControlSGTL5000","name":"sgtl5000_1","comment":"","x":700,"y":310,"z":"5d3343db.fec47c","bgColor":"#E6E0F8","wires":[]},{"id":"Synth_FilterEffects1","type":"FilterEffects","name":"FilterEffects","x":725,"y":390,"z":"5d3343db.fec47c","bgColor":"#CCFFCC","wires":[["Synth_i2s1:0","Synth_i2s1:1","Synth_usb1:0","Synth_usb1:1"]]},{"id":"Synth_i2s1","type":"AudioOutputI2S","name":"i2s1","comment":"","x":900,"y":345,"z":"5d3343db.fec47c","bgColor":"#E6E0F8","wires":[]},{"id":"Synth_usb1","type":"AudioOutputUSB","name":"usb1","comment":"","x":905,"y":410,"z":"5d3343db.fec47c","bgColor":"#E6E0F8","wires":[]}]


/**
 * All voices share the same two LFOs
 */
class LFOSources
{
 public:
    // LFO settings
    int lfo1Waveform = WAVEFORM_SINE;
    float lfo1Freq = 0.0;
    float lfo1Depth = 0.0;
    float lfo1PWM = 0.0;
    
    int lfo2Waveform = WAVEFORM_SINE;
    float lfo2Freq = 0.0;
    float lfo2Depth = 0.0;
    float lfo2PWM = 0.0;
    
    AudioSynthWaveform               LFO1;
    AudioSynthWaveform               LFO2;

    LFOSources() // constructor (this is called when class-object is created)
    {

    }

    void updateLFO1() {
      LFO1.begin(lfo1Waveform);
      LFO1.frequency(lfo1Freq);
      LFO1.amplitude(lfo1Depth);
      LFO1.pulseWidth(lfo1PWM);
    }
    
    void updateLFO2() {
      LFO2.begin(lfo2Waveform);
      LFO2.frequency(lfo2Freq);
      LFO2.amplitude(lfo2Depth);
      LFO2.pulseWidth(lfo2PWM);
    }
    
    
};

/**
 * A voice has two Osc, Noise and Wavetable. 
 * Each Osc are modulated by two external LFO.
 * Each voice has it's own ADSR so can be at a unique position in start/stop playing.
 */
class Voice
{
 public:
    // modulator settings
    int osc1Waveform = WAVEFORM_SINE;
    float osc1Amplitude = 1.0;
    int osc1Octave = 0;
    int osc1Semis = 0;
    float osc1Detune = 1.0; // can range 1.0 to 0.85
    float osc1PB = 1.0;
    osc_mod_t osc1Mod = Mod_FM;
    
    int osc2Waveform = WAVEFORM_SAWTOOTH;
    float osc2Amplitude = 1.0;
    int osc2Octave = 0;
    int osc2Semis = 0;
    float osc2Detune = 1.0; // can range 1.0 to 0.85
    float osc2PB = 1.0;
    osc_mod_t osc2Mod = Mod_FM;
    
    // noise settings
    float noiseAmplitude = 1.0;
    
    // wavetable
    int waveInstrument = 0; // piano
    float waveAmplitude = 1.0;
    
    // Mixer settings
    float osc1Amp = 1.0;
    float osc2Amp = 0.0;
    float noiseAmp = 0.0;
    float waveAmp = 0.0;
    
    // ADSR envelope settings
    float envAttack = 10.5;
    float envDecay = 35;
    float envSustain = 0.5;
    float envRelease = 300;
    
    AudioSynthWaveformModulated      VCO1;
    AudioSynthWaveformModulated      VCO2;
    AudioSynthWavetable              WaveTable;
    AudioSynthNoisePink              pinkNoise;
    AudioMixer4                      VoiceMixer;
    AudioEffectEnvelope              ADSR;
    AudioConnection                  *patchCord[5]; // total patchCordCount:5 including array typed ones.

    Voice() // constructor (this is called when class-object is created)
    {
        int pci = 0; // used only for adding new patchcords


        patchCord[pci++] = new AudioConnection(VCO1, 0, VoiceMixer, 0);
        patchCord[pci++] = new AudioConnection(VCO2, 0, VoiceMixer, 1);
        patchCord[pci++] = new AudioConnection(WaveTable, 0, VoiceMixer, 2);
        patchCord[pci++] = new AudioConnection(pinkNoise, 0, VoiceMixer, 3);
        patchCord[pci++] = new AudioConnection(VoiceMixer, 0, ADSR, 0);
    }

    void updateMix(Mix_change_t change) {
      VoiceMixer.gain(0, osc1Amp);  
      VoiceMixer.gain(1, osc2Amp);
      VoiceMixer.gain(2, waveAmp);
      VoiceMixer.gain(3, noiseAmp);
      updateMixerBars(change);
    }
    
    
    void updateADSR(ADSR_change_t change) {
      ADSR.attack(envAttack);
      ADSR.decay(envDecay);
      ADSR.sustain(envSustain);
      ADSR.release(envRelease);
      updateADSRBars(change);
    }
    
    void updateOsc1() {
      VCO1.begin(osc1Waveform);
      VCO1.amplitude(osc1Amplitude);
      if (osc1Mod == Mod_FM) {
        //TODO: consider allowing freq mod range to be changed
        VCO1.frequencyModulation(12);
      }
      else {
        //TODO: consider allowing phase mod range to be changed
        VCO1.phaseModulation(180);
      }
    }
    
    void updateOsc2() {
      VCO2.begin(osc2Waveform);
      VCO2.amplitude(osc2Amplitude);
      if (osc2Mod == Mod_FM) {
        VCO2.frequencyModulation(12);
      }
      else {
        VCO2.phaseModulation(180);
      }
    }
    
    void updateNoise() {
      pinkNoise.amplitude(noiseAmplitude);
    }
    
    void updateWave() {
      WaveTable.amplitude(waveAmplitude);
      Wavetable.setInstrument(*GMinst[waveInstrument]);
    }
    
    
};

class FilterEffects
{
 public:
    // filter ADSR
    float filtEnvA = 10.5;
    float filtEnvD = 35;
    float filtEnvS = 0.5;
    float filtEnvR = 300;
    
    // filter main variables
    filter_band_t filtBand = LPF;
    float filterFreq = 5000;
    float filterRes = 2.5;
    float filtDC = 1.0;
    int filtMod = 0;
    
    // chorus
    int chorusVoices;
    // Number of samples in each delay line
    // Allocate the delay lines for left and right channels
    short delayline[CHORUS_DELAY_LENGTH];
    
    
    AudioFilterStateVariable         filter1;
    AudioSynthWaveformDc             dc1;
    AudioEffectEnvelope              FilterADSR;
    AudioMixer4                      FilterSelect;
    AudioAmplifier                   ModSwitch;
    AudioEffectChorus                chorus1;
    AudioConnection                  *patchCord[7]; // total patchCordCount:7 including array typed ones.

    FilterEffects() // constructor (this is called when class-object is created)
    {
        int pci = 0; // used only for adding new patchcords


        patchCord[pci++] = new AudioConnection(filter1, 0, FilterSelect, 1);
        patchCord[pci++] = new AudioConnection(filter1, 1, FilterSelect, 2);
        patchCord[pci++] = new AudioConnection(filter1, 2, FilterSelect, 3);
        patchCord[pci++] = new AudioConnection(dc1, 0, FilterADSR, 0);
        patchCord[pci++] = new AudioConnection(FilterADSR, 0, ModSwitch, 0);
        patchCord[pci++] = new AudioConnection(FilterSelect, 0, chorus1, 0);
        patchCord[pci++] = new AudioConnection(ModSwitch, 0, filter1, 1);
    }

    void updateFiltADSR() {
      FilterADSR.attack(filtEnvA);
      FilterADSR.decay(filtEnvD);
      FilterADSR.sustain(filtEnvS);
      FilterADSR.release(filtEnvR);
      dc1.amplitude(filtDC);
      if (filtMod == 0) {
        ModSwitch.gain(0.0);
      }
      else {
        ModSwitch.gain(1.0);
      }
    }
    
    void updateFilterBand() {
      switch(filtBand) {
        case FILT_OFF:
          FilterSelect.gain(0, 1.00);
          FilterSelect.gain(1, 0);
          FilterSelect.gain(2, 0);
          FilterSelect.gain(3, 0);
          break;
    
        case LPF:
          FilterSelect.gain(0, 0);
          FilterSelect.gain(1, 1.0);
          FilterSelect.gain(2, 0);
          FilterSelect.gain(3, 0);
          break;
    
        case BPF:
          FilterSelect.gain(0, 0);
          FilterSelect.gain(1, 0);
          FilterSelect.gain(2, 1.0);
          FilterSelect.gain(3, 0);
          break;
    
        case HPF:
          FilterSelect.gain(0, 0);
          FilterSelect.gain(1, 0);
          FilterSelect.gain(2, 0);
          FilterSelect.gain(3, 1.0);
         break;
      }
    }
    
    void updateFilter() {
      filter1.frequency(filterFreq);
      filter1.resonance(filterRes);
    }
    
    void initChorus() {
      chorusVoices = 0; // off by default
    
      // Initialize the effect
      // address of delayline
      // total number of samples in the delay line
      // number of voices in the chorus INCLUDING the original voice
      if(!chorus.begin(delayline, CHORUS_DELAY_LENGTH, 6)) {
        Serial.println("AudioEffectChorus - left channel begin failed");
        while(1);
      }
    }
    
    void updateChorus() {
      chorus.voices(chorusVoices);
    }
    
};

class Arpeggiator
{
 public:
    // Arpeggiator
    arp_mode_t arpMode;
    int arpOctave;
    float arpPeriod;
    bool arpLatch;
    float arpDelay;
    bool arpDelayActive;
    int arpTranspose;
    byte arpNotes[NumStoredNotes]; 
    int arpStoreIndex;
    int arpPlayIndex;
    int arpNumDown;
    int arpIncrement;
    int arpPlayOctave;
    int arpScaleMode;
    
    

    Arpeggiator() // constructor (this is called when class-object is created)
    {

    }

    void sortNotes() {
    /* From Wikipedia 
     *   
    procedure bubbleSort(A : list of sortable items)
        n := length(A)
        repeat
            newn := 0
            for i := 1 to n - 1 inclusive do
                if A[i - 1] > A[i] then
                    swap(A[i - 1], A[i])
                    newn := i
                end if
            end for
            n := newn
        until n ≤ 1
    end procedure
    */
      int newLen;
      int len = arpStoreIndex + 1;
    #ifdef DEBUG_SORT  
      Serial.print("Input = ");
      for (int i = 0; i < arpStoreIndex; i++) {
        Serial.printf("%d ", arpNotes[i]);
      }
      Serial.println();
    #endif  
      do {
        newLen = 0;
        
        for (int i = 1; i < (len - 1); i++) {
          if (arpNotes[i - 1] > arpNotes[i]) {
            byte temp = arpNotes[i - 1];
            arpNotes[i - 1] = arpNotes[i];
            arpNotes[i] = temp;
            newLen = i + 1;
          }
        }
        len = newLen;
      } while(len > 1);
    }
    
    void init() {
      arpMode = Arp_Off;
      arpLatch = false;
      arpOctave = 0;
      arpPeriod = 1000;
      arpDelay = 0;
      arpTranspose = 0;
    }
    
    void update() {
      if (arpMode != Arp_Off) {
        // play Arpeggiator notes
        if (arpStoreIndex != 0) { // any notes in the array to play?
          // are we in a post sequence delay?
          if ((arpDelay != 0) && (arpDelayActive == true)) {
            if (lastMillis > arpPeriod) {
    //          Serial.printf("Osc off because lasmillis (%lu) beyond arpPeriod (%u)", lastMillis, arpPeriod);
              oscillatorsOff();
            }
            if (lastMillis > arpDelay) {
              arpDelayActive = false;
              Serial.println("Delay stop");
              lastMillis = 0;
            }
          }
          else if (lastMillis > arpPeriod) {
            byte note2play;
            lastMillis = 0;
            Serial.print("[ ");
            for (int i = 0; i < arpStoreIndex; i++) {
              Serial.print(arpNotes[i]);
              if (i == arpPlayIndex) {
                Serial.print('*');
              }
              Serial.print(' ');
            }
            Serial.printf("] Octave=%u\n", arpPlayOctave);
            note2play = arpNotes[arpPlayIndex] + arpTranspose + (12 * arpPlayOctave);
    //        Serial.println("Osc off because arpPeriod expired - cancel last playing note");
            if (arpMode != Arp_Record) {
              oscillatorsOff(); // end previous note
              oscillatorsOn(note2play); // start new note from ARP array
            }
            switch(arpMode) {
              case Arp_Up:
              case Arp_Scale:
                arpPlayIndex++;
                if (arpPlayIndex >= arpStoreIndex) {
                  arpPlayIndex = 0;
                  if (arpPlayOctave < arpOctave) {
                    arpPlayOctave++;
                  }
                  else {
                    arpDelayActive = true;
                    arpPlayOctave = 0;
                    Serial.println("Up: Delay start");
                  }
                }
                break;
              case Arp_Down:
                arpPlayIndex--;
                if (arpPlayIndex < 0) {
                  arpPlayIndex = arpStoreIndex - 1;
                  if (arpPlayOctave > 0) {
                    arpPlayOctave--;
                  }
                  else {
                    arpDelayActive = true;
                    arpPlayOctave = arpOctave;
                    Serial.println("Dn: Delay start");
                  }
                }
                break;
              case Arp_UpDown:
                arpPlayIndex += arpIncrement;
                if (arpPlayIndex >= arpStoreIndex) {
                  if (arpPlayOctave < arpOctave) {
                    arpPlayOctave++;
                    arpPlayIndex = 0;
                  }
                  else {
                    arpPlayIndex--;
                    arpIncrement = -arpIncrement;
                    arpDelayActive = true;
                    Serial.println("Up*: Delay start");
                  }
                }
                if (arpPlayIndex < 0) {
                  if (arpPlayOctave > 0) {
                    arpPlayOctave--;
                    arpPlayIndex = arpStoreIndex - 1;
                  }
                  else {
                    arpPlayIndex++;
                    arpIncrement = -arpIncrement;
                    arpDelayActive = true;
                    Serial.println("Dn*: Delay start");
                  }
                }
                break;
             case Arp_Random:
                arpPlayIndex = rand() % arpStoreIndex;
                if (arpOctave > 0) {
                  arpPlayOctave = rand() % (arpOctave + 1);
                }
                else {
                  arpPlayOctave = 0;
                }
                break;
            }
          }
        }
      }
    }
    
};

class ContinuousController
{
 public:

    ContinuousController() // constructor (this is called when class-object is created)
    {

    }

    void OnControlChange(byte channel, byte control /* CC num*/, byte value /* 0 .. 127 */) {
      int n;
      Serial.printf("CC: %u = %u ==> ", control, value);
      switch(control) {
        case 1:
          Serial.println("Mod wheel");
          break;
        // ====================== MIXER =====================
        case 75:
          osc1Amp =  velocity2amplitude[value];
          Serial.printf("Mix: Osc1 amplitude = %.2f\n", osc1Amp);
          updateMix(OSC1);
          break;
    
        case 76:
          osc2Amp = velocity2amplitude[value];
          Serial.printf("Mix: Osc2 amplitude = %.2f\n", osc2Amp);
          updateMix(OSC2);
          break;
    
        case 77:
          waveAmp = velocity2amplitude[value];
          Serial.printf("Mix: Wavetable amplitude = %.2f\n", waveAmp);
          updateMix(WaveTable);
          break;
    
        case 102:
          noiseAmp = velocity2amplitude[value];
          Serial.printf("Mix: Noise amplitude = %.2f\n", noiseAmp);
          updateMix(Noise);
          break;
    
        // ======================== Amp ADSR ==========================
        case 103:
          envAttack = mapf(value, 0, 127, 0.0, 3000.0);
          Serial.printf("Attack = %.2f\n", envAttack);
          updateADSR(Attack);
          break;
    
        case 104:
          envDecay = mapf(value, 0, 127, 0.0, 3000.0);
          Serial.printf("Decay = %.2f\n", envDecay);
          updateADSR(Decay);
          break;
    
        case 105:
          envSustain = mapf(value, 0, 127, 0.0, 1.0);
          Serial.printf("Sustain = %.2f\n", envSustain);
          updateADSR(Sustain);
          break;
    
        case 106:
          envRelease = mapf(value, 0, 127, 0.0, 3000.0);
          Serial.printf("Release = %.2f\n", envRelease);
          updateADSR(Release);
          break;
    
        // ========================= FILTER =======================
        case 107:
          value /= 20;
          if (value == 0) {
            filtBand = FILT_OFF;
          }
          else if (value == 1) {
            filtBand= LPF;
          }
          else if (value = 2) {
            filtBand= BPF;
          }
          else {
            filtBand = HPF;
          }
          Serial.printf("Filter band = %s\n", bands[filtBand]);
          updateFilterBand();
          break;
    
        case 108:
          filterFreq = mapf(value, 0, 127, 0, 10000);
          Serial.printf("Filter Freq = %.2fHz\n", filterFreq);
          updateFilter();
          break;
    
        case 109:
          filterRes = mapf(value, 0, 127, 0.7, 5.0);
          Serial.printf("Resonance = %.2f\n", filterRes);
          updateFilter();
          break;
    
        // =================== WAVE SHAPE ======================
        case 110:
        case 111:
        case 116:
        case 117:
          int change;
          value /= 10;
          switch (value) {
            case 0:
              // nothing for now as it'll be used to disable source below
              break;
            case 1:
            default:
              change = WAVEFORM_SINE;
              break;
            case 2:
              change = WAVEFORM_SAWTOOTH;
              break;
            case 3:
              change = WAVEFORM_SAWTOOTH_REVERSE;
              break;
            case 4:
              change = WAVEFORM_SQUARE;
              break;
            case 5:
              change = WAVEFORM_TRIANGLE;
              break;
            case 6:
              change = WAVEFORM_SAMPLE_HOLD;
              break;
            case 7:
              change = WAVEFORM_ARBITRARY;
              break;
            case 8:
              change = WAVEFORM_PULSE;
              break;
          }
          Serial.printf("Wave: %s (", (value == 0) ? "Off" : waves[change]);
          if (control == 110) {
            Serial.println("LFO1)");
            if (value == 0) {
              LFO1switch.gain(0);          
            }
            else {
              LFO1switch.gain(1.0);
              lfo1Waveform = change;
              updateLFO1();
            }
          }
          if (control == 111) {
            Serial.println("LFO2)");
            if (value == 0) {
              LFO2switch.gain(0);
            }
            else {
              LFO2switch.gain(1.0);
              lfo2Waveform = change;
              updateLFO2();
            }
          }
          if (control == 116) {
            Serial.println("OSC1)");
            if (value == 0) {
              Osc1switch.gain(0);
            }
            else {
              Osc1switch.gain(1.0);
              osc1Waveform = change;
              updateOsc1();
            }
          }
          if (control == 117) {
            Serial.println("OSC2)");
            if (value == 0) {
              Osc2switch.gain(0);
            }
            else {
              Osc2switch.gain(1.0);
              osc2Waveform = change;
              updateOsc2();
            }
          }
          break;
    
        // ===========================  LFO1 =====================
        case 112:
          if (value < 64) {
            lfo1Freq = mapf(value, 0, 64, 0.0, 20.0);        
          }
          else {
            lfo1Freq = mapf(value, 64, 127, 20.0, 200.0);
          }
          Serial.printf("LFO1 freq = %.2fHz\n", lfo1Freq);
          updateLFO1();
          break;
    
        case 114:
          lfo1Depth = mapf(value, 0, 127, 0.0, 0.2);
          Serial.printf("LFO1 depth = %.2f\n", lfo1Depth);
          updateLFO1();
          break;
    
        case 20:
          lfo1PWM = mapf(value, 0, 127, 0.0, 1.0);
          Serial.printf("LFO1 PWM = %.2f\n", lfo1PWM);
          updateLFO1();
          break;
    
        // ===================== LFO2 ========================
        case 113:
          if (value < 64) {
            lfo2Freq = mapf(value, 0, 64, 0.0, 20.0);        
          }
          else {
            lfo2Freq = mapf(value, 64, 127, 20.0, 200.0);
          }
          Serial.printf("LFO2 freq = %.2fHz\n", lfo2Freq);
          updateLFO2();
          break;
    
        case 115:
          lfo2Depth = mapf(value, 0, 127, 0.0, 0.2);
          Serial.printf("LFO2 depth = %.2f\n", lfo2Depth);
          updateLFO2();
          break;
    
        case 21:
          lfo2PWM = mapf(value, 0, 127, 0.0, 1.0);
          Serial.printf("LFO2 PWM = %.2f\n", lfo2PWM);
          updateLFO2();
          break;
    
        // ======================= OSC1 =======================
        case 118:
          osc1Semis = mapf(value, 0.0, 127, 0, 12);
          Serial.printf("Osc1 semis = %u\n", osc1Semis);
          updateOsc1();
          break;
    
        case 23:
          value = (value > 48) ? 48 : value;
          n = (value / 12) * 12;
          osc1Octave = n - 24;
          Serial.printf("Osc1 Octave: %d\n", osc1Octave);
          break;
    
        case 25:
          osc1Detune = mapf(value, 0, 127, 1.0, 0.85);
          Serial.printf("Osc1 detune = %.2f\n", osc1Detune);
          break;
    
        case 14:
          Serial.printf("Osc1 modulation = %s\n", value == 0 ? "FM" : "PM");
          // 0..63 = FM, 64..127 = PM
          if (value < 64) {
            osc1Mod = Mod_FM;
          }
          else {
            osc1Mod = Mod_PM;
          }
          break;
    
        // ======================= OSC2 ============================
        case 119:
          osc2Semis = mapf(value, 0, 127, 0.0, 12);
          Serial.printf("Osc2 semis = %u\n", osc2Semis);
          updateOsc2();
          break;
    
        case 26:
          value = (value > 48) ? 48 : value;
          n = (value / 12) * 12;
          osc2Octave = n - 24;
          Serial.printf("Osc2 Octave: %d\n", osc2Octave);
          break;
    
        case 27:
          osc2Detune = mapf(value, 0, 127, 1.0, 0.85);
          Serial.printf("Osc2 detune = %.2f\n", osc2Detune);
          break;
    
        case 15:
          Serial.printf("Osc2 modulation = %s\n", value == 0 ? "FM" : "PM");
          // 0..63 = FM, 64..127 = PM
          if (value < 64) {
            osc2Mod = Mod_FM;
          }
          else {
            osc2Mod = Mod_PM;
          }
          break;
    
        // ======================== Filter ADSR =======================
        case 22:
          filtEnvA = mapf(value, 0, 127, 0.0, 3000.0);
          Serial.printf("Filter Attack = %.2f\n", filtEnvA);
          updateFiltADSR();
          break;
    
        case 24:
          filtEnvD = mapf(value, 0, 127, 0.0, 3000.0);
          Serial.printf("Filter Decay = %.2f\n", filtEnvD);
          updateFiltADSR();
          break;
    
        case 28:
          filtEnvS = mapf(value, 0, 127, 0.0, 1.0);
          Serial.printf("Filter Sustain = %.2f\n", filtEnvS);
          updateFiltADSR();
          break;
    
        case 29:
          filtEnvR = mapf(value, 0, 127, 0.0, 3000.0);
          Serial.printf("Filter Release = %.2f\n", filtEnvR);
          updateFiltADSR();
          break;
    
        // ====================== FILTER ====================
        case 30:
          filtDC = mapf(value, 0, 127, -1.0, 1.0);
          Serial.printf("DC = %.2f\n", filtDC);
          updateFiltADSR();
          break;
    
        case 31:
          // use amp as a 0/1 switch for filter DC modulation
          filtMod = (value < 64) ? 0 : 1;
          Serial.printf("Modulation = %d\n", filtMod);
          updateFiltADSR();
          if (filtMod == 0) {
            dumpPatch();
          }
          break;
    
        // ===================== ARPEGGIATOR ===================
        case 85:
          value /= 20;
          value *= 20;
          if (value == 0) {
            arpMode = Arp_Off;
            Serial.println("Arp Off - Osc Off");
            oscillatorsOff();
            arpStoreIndex = 0;
            arpPlayIndex = 0;
          }
          else if (value == 20) {
            arpMode = Arp_Up;
            Serial.println("Arp Up");
            arpPlayIndex = 0;
            arpDelayActive = false;
            arpPlayOctave = 0;
          }
          else if (value == 40) {
            arpMode = Arp_Down;
            Serial.println("Arp Down");
            arpPlayIndex = 0;
            arpDelayActive = false;
            arpPlayOctave = arpOctave;
          }
          else if (value == 60) {
            arpMode = Arp_UpDown;
            Serial.println("Arp Up/Down");
            arpPlayIndex = 0;
            arpIncrement = 1; // start "up"
            arpDelayActive = false;
            arpPlayOctave = 0;
          }
          else if (value == 80) {
            arpMode = Arp_Random;
            Serial.println("Arp Random");
          }
          else if (value == 100) {
            Serial.println("Arp Scales");
            arpMode = Arp_Scale;
            arpPlayIndex = 0;
            arpDelayActive = false;
            arpPlayOctave = 0;
          }
          else if (value == 120) {
            Serial.println("Arp Record");
            arpMode = Arp_Record;
            arpStoreIndex = 0;
            arpPlayIndex = 0;
            arpDelayActive = false;
            arpPlayOctave = 0;
          }
          break;
    
        case 86:
          arpOctave = (value / 20);
          Serial.printf("Arp Octaves = %d\n", arpOctave + 1);
          break;
    
        case 87:
          arpLatch = (value >= 64) ? 1 : 0; // 0 /1
          if (value == 0) {
            arpPlayIndex = 0;
            arpStoreIndex = 0;
            arpPlayOctave = 0;
    //        Serial.println("Osc off because latch Off");
            oscillatorsOff();
          }
          Serial.printf("Arp Latch = %u\n", arpLatch);
          break;
    
        case 88:
          arpPeriod = mapf(value, 0, 127, 1200, 50); // not sure of units yet
          Serial.printf("Arp Period = %.2f\n", arpPeriod);
          break;
    
        case 89:
          arpDelay = mapf(value, 0, 127, 0, 2000);
          Serial.printf("Arp Delay = %.2f\n", arpDelay);
          break;
    
        case 90:
          arpTranspose = (int)mapf(value, 0, 127, 0, 11);
          Serial.printf("Arp Transpose = %u\n", arpTranspose);
          break;
    
        case 92:
          arpScaleMode = value;
          Serial.printf("Scale = %s\n", scaleModes[value].name);
          break;
    
        // ===================== CHORUS ====================
        case 91:
          value /= 20;
          value *= 20;
          if (value == 0) {
            chorusVoices = 0;
          }
          else if (value == 20) {
            chorusVoices = 2;
          }
          else if (value == 40) {
            chorusVoices = 4;
          }
          else if (value == 60) {
            chorusVoices = 6;
          }
          Serial.printf("Chorus = %u\n", chorusVoices);
          updateChorus();
          break;
    
        // ========================= PANIC =================
        case 123:
          // MIDI PANIC!!
          arpPlayIndex = 0;
          arpStoreIndex = 0;
          arpPlayOctave = 0;
          arpLatch = 0;
          Serial.println("Osc off because Panic");
          oscillatorsOff();
          break;
    
        default:
          // if unrecognised do nothing
          break;
      }
    }
    
    
};

class PitchBend
{
 public:

    PitchBend() // constructor (this is called when class-object is created)
    {

    }

    void onPitchChange(byte channel, int pitch) {
      float change = 0.0;
      Serial.printf("Pitch change: %d\n", pitch);
      if (pitch == 0) {
        osc1PB = 1.0;
        osc2PB = 1.0;
      }
      else {
        // pitch is -8192 to +8192 so convert that to -0.5 to +0.5
        change = (0.5 / 8192) * pitch;
        // so swing from 0.5 to 1.5
        osc1PB = 1.0 + change;
        osc2PB = 1.0 + change;
      }
      Serial.printf("Pitch change: %d so bend = %.05f, osc1PB = %.02f, osc2PB = %.02f\n", pitch, change, osc1PB, osc2PB);
      if (arpNumDown != 0) {
        // something already playing so retrigger with new freq
        oscillatorsOn();
      }
    }
    
    
};

class NoteHandling
{
 public:

    NoteHandling() // constructor (this is called when class-object is created)
    {

    }

    void OnNoteOn(byte channel, byte note, byte velocity) {
      Serial.printf("ch: %u, note: %u, vel: %u ", channel, note, velocity);
      digitalWrite(LED_PIN, HIGH);
      if (note >= 48) {
        highlightKey(note, true);
      }
      arpNumDown++;
      if (arpMode == Arp_Off) {
        oscillatorsOn(note);
      }
      else if (arpStoreIndex < 20) {
        Serial.println(); // finish note info logging
        // just consider adding notes to be played to the Arp array
    
        if ((arpMode == Arp_Scale) && (arpStoreIndex != 0)) {
          // already playing a scale so clear all notes to allow
          // new one to be added
          arpStoreIndex = 0;
          arpPlayIndex = 0;
          arpPlayOctave = 0;
        }
    
        // usually just add one note to the sequence
        arpNotes[arpStoreIndex] = note;
        Serial.printf("Added note %u at entry %u\n", note, arpStoreIndex);
        arpStoreIndex++;
    
        // but want a whole scale if in scale mode...
        if (arpMode == Arp_Scale) {
          int currNote = note;
          // but if Scale mode add all the other notes of this scale...
          for (int n = 0; n < scaleModes[arpScaleMode].entries; n++) {
            currNote += scaleModes[arpScaleMode].offsets[n];
            arpNotes[arpStoreIndex++] = currNote;
          }
        }
        if (arpMode != Arp_Record) {
          sortNotes();
        }
        else {
          // in record mode we simply record everything played in order (no sort)
          Serial.printf("Playing %u while recording\n", note);
          oscillatorsOn(note);
        }
      }
    }
    
    void OnNoteOff(byte channel, byte note, byte velocity) {
      if (note >= 48) {
        highlightKey(note, false);
      }
      digitalWrite(LED_PIN, LOW);
      arpNumDown--;
      if (!arpLatch) {
        // remove the off note from the array
        for (int i = 0; i < arpStoreIndex; i++) {
          if (arpNotes[i] == note) {
            // shuffle remaining back 1 to this slot
            for (int j = i + 1; j < arpStoreIndex; j++) {
              arpNotes[j - 1] = arpNotes[j];
            }
            // and reduce number in array.
            arpStoreIndex--;
            break;
          }
        }
      }
    //  Serial.println("Osc off because NoteOff");
      oscillatorsOff();
    }
    
    
};

class Synth
{
 public:
    const static int NumStoredNotes = 32;
    int clickCount = 0;
    elapsedMillis lastMillis = 0;
    elapsedMillis last_time = 0;
    long encPos = -999;
    int encVal = 0;
    
    // Use hardware SPI (on Uno, #13, #12, #11) and the above for CS/DC
    ILI9341_t3 tft = ILI9341_t3(TFT_CS, TFT_DC);
    XPT2046_Touchscreen ts(TOUCH_CS);
    Encoder enc(2,3);
    MIDI_CREATE_INSTANCE(HardwareSerial, Serial1, MIDI);
    
    byte currentNote;
    
    
    LFOSources                       LFOSources1;
    Voice                            Voice[8];
    AudioMixer<8>                    MixVoices;
    FilterEffects                    FilterEffects;
    AudioOutputI2S                   i2s1;
    AudioOutputUSB                   usb1;
    AudioControlSGTL5000 sgtl5000_1;
    AudioConnection                  *patchCord[30]; // total patchCordCount:30 including array typed ones.

    Synth() // constructor (this is called when class-object is created)
    {
        int pci = 0; // used only for adding new patchcords


        patchCord[pci++] = new AudioConnection(MixVoices, 0, FilterEffects.FilterSelect, 0);
        patchCord[pci++] = new AudioConnection(MixVoices, 0, FilterEffects.filter1, 0);
        patchCord[pci++] = new AudioConnection(FilterEffects.chorus1, 0, i2s1, 0);
        patchCord[pci++] = new AudioConnection(FilterEffects.chorus1, 0, i2s1, 1);
        patchCord[pci++] = new AudioConnection(FilterEffects.chorus1, 0, usb1, 0);
        patchCord[pci++] = new AudioConnection(FilterEffects.chorus1, 0, usb1, 1);
        for (int i = 0; i < 8; i++)
        {
            patchCord[pci++] = new AudioConnection(LFOSources1.LFO1, 0, Voice[i].VCO1, 0);
            patchCord[pci++] = new AudioConnection(LFOSources1.LFO2, 0, Voice[i].VCO2, 0);
            patchCord[pci++] = new AudioConnection(Voice[i].ADSR, 0, MixVoices, i);
        }
    }

    void dumpPatch() {
      Serial.println("====================================");
      Serial.printf( "OSC1: wave=%s, ampl=%.2f, octave=%d, semis=%u, detune=%.2f\n",
                      waves[osc1Waveform], osc1Amplitude, osc1Octave, osc1Semis, osc1Detune);
      Serial.printf( "LFO1: wave=%s, freq=%.2fHz, depth=%.2f, PWM=%.2f\n\n",
                      waves[lfo1Waveform], lfo1Freq, lfo1Depth, lfo1PWM);
      Serial.printf( "OSC2: wave=%s, ampl=%.2f, octave=%d, semis=%u, detune= %.2f\n",
                      waves[osc2Waveform], osc2Amplitude, osc2Octave, osc2Semis, osc2Detune);
      Serial.printf( "LFO2: wave=%s, freq=%.2fHz, depth=%.2f, PWM=%.2f\n\n",
                      waves[lfo2Waveform], lfo2Freq, lfo2Depth, lfo2PWM);
      Serial.printf( "Filter: band=%s, freq=%.2fHz, res=%.2f, DC=%.2f, modulated=%u\n\n",
                      bands[filtBand], filterFreq, filterRes, filtDC, filtMod);
      Serial.printf( "Mix ADSR: attack=%.2f, decay=%.2f, sustain=%.2f, release=%.2f\n",
                      envAttack, envDecay, envSustain, envRelease);
      Serial.printf( "Filter ADSR: attack=%.2f, decay=%.2f, sustain=%.2f, release=%.2f\n\n",
                      filtEnvA, filtEnvD, filtEnvS, filtEnvR);
      Serial.printf( "Mixer: osc1=%.2f, osc2=%.2f, noise=%.2f, wavetab=%.2f\n\n",
                      osc1Amp, osc2Amp, noiseAmp, waveAmp);
      Serial.printf( " Arpeggiator: arpMode=%s, arpPeriod=%.2f, arpOctave=%u, arpLatch=%u, arpDelay=%.2f, arpTranspose=%d\n",
                      arpModes[arpMode], arpPeriod, arpOctave, arpLatch, arpDelay, arpTranspose);
      Serial.println("====================================");
    }
    
    double mapf(double x, double in_min, double in_max, double out_min, double out_max)
    {
        return (x - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;
    }
    
    
    void oscillatorsOn() {
      oscillatorsOn(currentNote);
    }
    
    void oscillatorsOn(byte playNote) {
      currentNote = playNote; // in case we need to retrigger after recalculating pitch bend
      
      byte note;
      note = playNote;  
    
      note += osc1Octave; // -24, -12, 0, 12 or 24
      note += osc1Semis;
      if (note < 0) {
        note = 0;
      }
      if (note > 127) {
        note = 127;
      }
      Serial.printf("Osc1 note=%d (%s%u) ", note, noteNames[note %12], (note / 12) - 1);
      float freq = tune_frequencies2_PGM[note];
      freq *= osc1Detune; // mult 0.85 .. 1.0
      freq *= osc1PB;
      Serial.printf("so freq1 = %.2fHz, ", freq);
      waveformMod1.frequency(freq);
    
      wavetable1.playFrequency(freq, 127);
    
      note = playNote;
      note += osc2Octave; // -24, -12, 0, 12 or 24
      note += osc2Semis;
      if (note < 0) {
        note = 0;
      }
      if (note > 127) {
        note = 127;
      }
      Serial.printf("Osc2 note=%d (%s%u) ", note, noteNames[note %12], (note / 12) - 1);
      freq = tune_frequencies2_PGM[note];
      freq *= osc2Detune; // mult 0.85 .. 1.0
      freq *= osc2PB;
      Serial.printf("freq2 = %.2fHz\n", freq);
      waveformMod2.frequency(freq);
      // sound ADSR
      envelope1.noteOn();
      // filter ADSR
      envelope2.noteOn();
    //  Serial.println("Both Env triggered");
    }
    
    void oscillatorsOff() {
      envelope1.noteOff();
      envelope2.noteOff();
      wavetable1.stop();
    }
    
    void onProgramChange(byte channel, byte program) {
      waveInstrument = program & 0x7F; // currently so limit 0..127
      Serial.printf("Progran change: %u = %s\n", waveInstrument, instrumentNames[waveInstrument]);
      updateWave();
    }
    
    void init() {
      pinMode(LED_PIN, OUTPUT);
      pinMode(JOY_SW, INPUT_PULLUP);
      Serial.begin(9600);
      Serial1.begin(31250);
      Serial.println("The bastard is Alive!");
      MIDI.begin();
      ts.begin();
      ts.setRotation(3);
      tftInit(); 
      AudioMemory(20);
      sgtl5000_1.enable();
      sgtl5000_1.volume(0.75);
      updateOsc1();
      updateOsc2();
      updateNoise(); // this probably fixed at 1.0 (mixer varies level)
      updateLFO1();
      updateLFO2();
      updateWave();
      updateMix(AllMix);
      updateADSR(AllADSR);
      updateFiltADSR();
      updateFilterBand();
      updateFilter();
      initChorus();
      updateChorus();
      arp.init();
      usbMIDI.setHandleNoteOff(OnNoteOff);
      usbMIDI.setHandleNoteOn(OnNoteOn);
      usbMIDI.setHandleControlChange(OnControlChange);
      usbMIDI.setHandlePitchChange(onPitchChange);
      usbMIDI.setHandleProgramChange(onProgramChange);
    
      MIDI.setHandleNoteOff(OnNoteOff);
      MIDI.setHandleNoteOn(OnNoteOn);
      MIDI.setHandleControlChange(OnControlChange);
      MIDI.setHandlePitchBend(onPitchChange);
      MIDI.setHandleProgramChange(onProgramChange);
    }
    
    void update() {
      // put your main code here, to run repeatedly:
      usbMIDI.read();
      MIDI.read()
    
    #ifdef USE_TOUCH
      if (ts.touched()) {
        int X, Y;
        TS_Point p = ts.getPoint();
        X = p.x - 231;
        X = map(X, 3482, 0, 0, 320);
        Y = p.y - 360;
        Y = map(Y, 3465, 0, 0, 240);
        tft.setFont(Arial_14);
        tft.fillRect(240, 5, 100, 30, ILI9341_BLACK);
        tft.setTextColor(ILI9341_RED);
        tft.setCursor(240, 5);
        int Aval;
        Aval = pointInBar(X, Y, ADSR_PANEL_X + 5, ADSR_PANEL_Y);
        if (Aval > 0) {
          tft.print(Aval);
          OnControlChange(1, 103, Aval);
        }
        int Dval;
        Dval = pointInBar(X, Y, ADSR_PANEL_X + 30, ADSR_PANEL_Y);
        if (Dval > 0) {
          tft.print(Dval);
          OnControlChange(1, 104, Dval);
        }
        int Sval;
        Sval = pointInBar(X, Y, ADSR_PANEL_X + 55, ADSR_PANEL_Y);
        if (Sval > 0) {
          tft.print(Sval);
          OnControlChange(1, 105, Sval);
        }
        int Rval;
        Rval = pointInBar(X, Y, ADSR_PANEL_X + 80, ADSR_PANEL_Y);
        if (Rval > 0) {
          tft.print(Rval);
          OnControlChange(1, 106, Rval);
        }
        int O1val;
        O1val = pointInBar(X, Y, MIX_PANEL_X + 5, MIX_PANEL_Y);
        if (O1val > 0) {
          tft.print(O1val);
          OnControlChange(1, 100, O1val);
        }
        int O2val;
        O2val = pointInBar(X, Y, MIX_PANEL_X + 30, MIX_PANEL_Y);
        if (O2val > 0) {
          tft.print(O2val);
          OnControlChange(1, 101, O2val);
        }
        int Nval;
        Nval = pointInBar(X, Y, MIX_PANEL_X + 55, MIX_PANEL_Y);
        if (Nval > 0) {
          tft.print(Nval);
          OnControlChange(1, 102, Nval);
        }
      }
      #endif
    
      arp.update();
      if(0) {
        if(last_time >= 5000) {
          Serial.print("Proc = ");
          Serial.print(AudioProcessorUsage());
          Serial.print(" (");    
          Serial.print(AudioProcessorUsageMax());
          Serial.print("),  Mem = ");
          Serial.print(AudioMemoryUsage());
          Serial.print(" (");    
          Serial.print(AudioMemoryUsageMax());
          Serial.println(")");
          last_time = 0;
        }
      }
    }
    
    
};
// TeensyAudioDesign: end automatically generated code
